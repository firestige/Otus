' Activity + Sequence diagrams for decoder.Process entry point
' Generated from decoder.go behavior (Process -> decode -> defrag -> transport -> app processing)

@startuml DecoderActivity
title Decoder.Process activity (high level)

start
:Receive raw packet data;
:Dedup/filter checks;
:parser.DecodeLayers(data, &decodedLayers);

if (found GRE?) then (yes)
  :handle GRE -> parser.DecodeLayers(inner);
  note right: may re-populate decodedLayers
endif

partition "Layer loop" {
  repeat
    :pop next layerType;
    if (layerType == IPv4) then (ipv4)
      if (not fragmented) then (no)
        :processTransport(..., ip4.NetworkFlow(), protocol);
      else (yes)
        :ip4New, err := d.defragIP4(d.ip4, ts);
        if (ip4New == nil) then (incomplete)
          :increment fragCount; 
          stop
        else (reassembled)
          :parserUDP/ parserTCP.DecodeLayers(ip4New.Payload,...);
          :processTransport(..., ip4New.NetworkFlow(), ip4New.Protocol);
        endif
      endif
    else (layer == IPv6)
      if (nextHeader != IPv6Fragment) then (no)
        :processTransport(..., ip6.NetworkFlow(), nextHeader);
      else (yes)
        :ip6New := d.defragIP6(...);
        if (ip6New == nil) then (incomplete)
          :increment fragCount;
          stop
        else
          :parserUDP/ parserTCP.DecodeLayers(ip6New.Payload,...);
          :processTransport(..., ip6New.NetworkFlow(), ip6New.NextHeader);
        endif
      endif
    endif
  repeat while (more layers)
}

stop
@enduml

@startuml DecoderSequence
title Decoder.Process sequence (detailed)

actor PacketSource
participant "Decoder.Process" as Process
participant "DecodingLayerParser" as Parser
participant "ip4defrag" as Defrag4
participant "ip6defrag" as Defrag6
participant "processTransport" as Transport
participant "UDP handler" as UDP
participant "TCP handler" as TCP
participant "SCTP handler" as SCTP
participant "tcpassembly.Assembler" as Asm
participant "tcpStreamFactory.New / tcpStream" as tcpStream
participant "correlateRTCP / extractCID / app processors" as App
participant "PacketQueue" as Queue

== parse incoming ==
PacketSource -> Process : Process(data, ci)
Process -> Parser : DecodeLayers(data, &decodedLayers)
Parser --> Process : decodedLayers

alt GRE present
  Process -> Parser : DecodeLayers(gre.Payload, &decodedLayers)
  Parser --> Process : inner layers
end

loop iterate decodedLayers
  alt layer == IPv4
    Process -> Process : check fragmentation flags
    alt not fragmented
      Process -> Transport : processTransport(..., ip4.NetworkFlow(), ip4.Protocol)
    else fragmented
      Process -> Defrag4 : defragIP4(d.ip4, ts)
      alt not complete
        Defrag4 --> Process : nil (wait for more fragments)
      else reassembled
        Defrag4 --> Process : ip4New
        Process -> Parser : parserUDP/ parserTCP.DecodeLayers(ip4New.Payload)
        Parser --> Process : decodedLayers (for reassembled payload)
        Process -> Transport : processTransport(..., ip4New.NetworkFlow(), ip4New.Protocol)
      end
    end
  else layer == IPv6
    Process -> Process : check ip6.NextHeader
    alt not fragment
      Process -> Transport : processTransport(..., ip6.NetworkFlow(), ip6.NextHeader)
    else fragment
      Process -> Defrag6 : defragIP6(d.ip6, ip6frag, ts)
      alt not complete
        Defrag6 --> Process : nil (wait)
      else reassembled
        Defrag6 --> Process : ip6New
        Process -> Parser : parserUDP/ parserTCP.DecodeLayers(ip6New.Payload)
        Parser --> Process : decodedLayers
        Process -> Transport : processTransport(..., ip6New.NetworkFlow(), ip6New.NextHeader)
      end
    end
  else
    Process -> Process : handle other layers
  end
end

== transport processing ==
Transport -> Transport : loop over decodedLayers
alt UDP
  Transport -> UDP : set pkt fields, udp.Payload
  alt RTP/RTCP detection
    UDP -> App : correlateRTCP(...) [RTCP]
    alt correlate success
      App --> Transport : pkt.Payload, CID
      Transport -> Queue : PacketQueue <- pkt (enqueue RTCP)
    else correlate fail
      App --> Transport : nil (increment rtcpFailCount)
    end
  else RTP
    UDP -> App : protos.NewRTP for debug (optional)
    Transport -> Transport : drop payload / return
  end
  Transport -> App : extractCID(src,dst,payload) (SIP over UDP path)
else TCP
  Transport -> TCP : set pkt fields
  alt config.Cfg.Reassembly == true
    TCP -> Asm : AssembleWithTimestamp(flow, tcp, ts)
    note right: gopacket tcpassembly will create stream via factory
    Asm -> tcpStream : New stream / Reassembled -> tcpStream.Reassembled(...)
    tcpStream -> App : process reassembled bytes (extractCID / SIP parsing)
    tcpStream -> Queue : enqueue SIP HEP packets as needed
  else if config.Cfg.SipAssembly
    TCP -> Transport : checkTransport(...) aggregate fragments
    Transport -> App : extractCID on assembled payloads
  else
    Transport -> App : extractCID(pkt.Payload)
  end
else SCTP
  Transport -> SCTP : set pkt fields, parse chunk, set payload
  Transport -> App : extractCID(pkt.Payload)
end

@enduml

@startuml Decoder class view

class Decoder {
  - asm: *tcpassembly.Assembler
  - defrag4: *ip4defrag.IPv4Defragmenter
  - defrag6: *ip6defrag.IPv6Defragmenter
  - layerType: gopacket.LayerType
  - decodedLayers: []gopacket.LayerType
  - parser: *gopacket.DecodingLayerParser
  - parserUDP: *gopacket.DecodingLayerParser
  - parserTCP: *gopacket.DecodingLayerParser
  - sll: layers.LinuxSLL
  - d1q: layers.Dot1Q
  - gre: layers.GRE
  - eth: layers.Ethernet
  - etherip: layers.EtherIP
  - vxl: ownlayers.VXLAN
  - hperm: ownlayers.HPERM
  - ip4: layers.IPv4
  - ip6: layers.IPv6
  - tcp: layers.TCP
  - udp: layers.UDP
  - dns: layers.DNS
  - sctp: layers.SCTP
  - payload: gopacket.Payload
  - dedupCache: *freecache.Cache
  - filter: []string
  - filterIP: []string
  - filterSrcIP: []string
  - filterDstIP: []string
  - cachePayload: *freecache.Cache
  - lastStatTime: time.Time
  - stats
  --
  + defragIP4(i4: layers.IPv4, t: time.Time): (*layers.IPv4, error)
  + defragIP6(i6: layers.IPv6, i6frag: layers.IPv6Fragment, t: time.Time): (*layers.IPv6, error)
  + Process(data: []byte, ci: *gopacket.CaptureInfo)
  + addCachePayload(cachePayload: *CachePayload): bool
  + checkTransport(...)
  + processTransport(...)
  + ProcessHEPPacket(data: []byte)
  + SendPingHEPPacket()
  + SendExitHEPPacket()
}

class Packet {
  Version: byte
  Protocol: byte
  SrcIP: net.IP
  DstIP: net.IP
  SrcPort: uint16
  DstPort: uint16
  Tsec: uint32
  Tmsec: uint32
  ProtoType: byte
  Payload: []byte
  CID: []byte
  Vlan: uint16
  Mos: uint16
  TCPFlag: uint8
  IPTos: uint8
  --
  + GetVersion(): uint32
  + GetProtocol(): uint32
  + GetSrcIP(): string
  + GetDstIP(): string
  + GetSrcPort(): uint16
  + GetDstPort(): uint16
  + GetTsec(): uint32
  + GetTmsec(): uint32
  + GetProtoType(): uint32
  + GetPayload(): string
  + GetCID(): string
}

class CachePayload {
  SrcIP: net.IP
  SrcPort: uint16
  DstIP: net.IP
  DstPort: uint16
  AckNumber: uint32
  SeqNumber: uint32
  NextSeqNumber: uint32
  RemainLength: int
  FrameCount: int
  Payload: []byte
}

class HEP {
  Version: uint32
  Protocol: uint32
  SrcIP: string
  DstIP: string
  SrcPort: uint32
  DstPort: uint32
  Tsec: uint32
  Tmsec: uint32
  ProtoType: uint32
  NodeID: uint32
  NodePW: string
  Payload: string
  CID: string
  Vlan: uint32
  ProtoString: string
  Timestamp: time.Time
  SIP: string
  NodeName: string
  TargetName: string
  SID: string
}

class Context {
  CaptureInfo: gopacket.CaptureInfo
  --
  + GetCaptureInfo(): gopacket.CaptureInfo
}

class stats {
  fragCount: uint64
  dupCount: uint64
  dnsCount: uint64
  ip4Count: uint64
  ip6Count: uint64
  rtcpCount: uint64
  rtcpFailCount: uint64
  tcpCount: uint64
  hepCount: uint64
  sctpCount: uint64
  udpCount: uint64
  unknownCount: uint64
}

Decoder "1" *-- "1" stats
Decoder ..> Packet : creates/uses
Decoder ..> CachePayload : uses
Decoder ..> HEP : uses
Decoder ..> Context : uses

@enduml